\documentclass[fontsize = 10pt,DIV = 13]{scrartcl}


\usepackage{amsmath}
\usepackage[noabbrev]{cleveref}
\usepackage{comment}
\usepackage{minted}
\usepackage{mdframed}  
\usepackage{xcolor}

\title{Direct solvers for dense matrices}


\newcommand{\pth}[1]{\left(#1\right)}
\surroundwithmdframed[linewidth=0pt, backgroundcolor=black!10]{minted} 

\begin{document}

\maketitle

\begin{abstract}
No abstract.
\end{abstract}
\newpage
\tableofcontents
\newpage

\section{Introduction}

\subsection{Introduction}
Physical simulations and collision detection algorithms often need to solve linear equation systems of the form

\begin{align}
\label{eq:linearSystem}
\mathbf{A}\mathbf{x}=\mathbf{r}
\end{align}

$\mathbf{A}$ is known matrix of size $\mathrm{N}\times\mathrm{N}$ and $\mathbf{r}$ a known column vector of size $\mathrm{N}$.
The column vector $\mathbf{x}$ is also of size $\mathrm{N}$ but its values are unknown.

 


The subject of this document is how  unknown values of $\mathbf{x}$ can be determined. 
Different solvers and their efficient implementation in C++ using SSE and AVX instructions are discussed.
The performance of each method depends on parameters like the system size $\mathrm{N}$, the symmetry of $\mathbf{A}$ and the number of solves with different $\mathbf{r}$ but identical $\mathbf{A}$.
Therefore, \cref{sec:solverSelection} discusses when which solver should be utilized to obtain maximal performance.


\subsection{Solver classes and functions}

Most of the solvers are based on complex algorithms with multiple sub-steps and don't fit into a single function.
The corresponding functions are grouped inside of classes which contain only static member functions.
Classes are chosen over name spaces to protect certain functions from external access.
The constructors are deleted because creating actual objects from those classes is not intended.

The public interfaces work with matrices and vectors as data arrays instead of matrix and vector classes.
The matrix data is expected to be in column major ordering.
This makes them more flexible since they can be used in other algorithms that manipulate the data directly without the need to create an unnecessary matrix or vector class.
However, there also wrapper functions to use the solvers directly with matrix and vector classes.


Specific implementation  details of the solver classes are discussed in the implementation sections of the corresponding solver.




\begin{comment}


\subsection{Notation}

This document uses bold symbols for matrices and vectors.
Bold capital letters like $\mathbf{A}$ are used for matrices.
Lower case bold letters are used for vectors ($\mathbf{r}$, $\mathbf{x}$).
The individual elements of a vector are given by:

\begin{align*}
\mathbf{x}
=
\begin{bmatrix}
x_0\\
x_1\\
\vdots\\
x_{N-1}
\end{bmatrix}
\end{align*}

Zero based indexing is used since this makes it easier to translate the equations into C++ code.


The individual components of the matrix $\mathbf{A}$ can be distinguished by a single column specific character and a zero based row index.
The column specific characters start with the character $a$ for the first column and increase alphabetically.
For example, the components of $\mathbf{A}$ with size $3 \times 3$ are:

\begin{align*}
\mathbf{A}
=
\begin{bmatrix}
a_0&b_0&c_0\\
a_1&b_1&c_1\\
a_2&b_2&c_2
\end{bmatrix}
\end{align*}

This element naming is chosen because it can be easier translated into vectorized code than the common double index notation.
\end{comment}



\input{sections/cramersRule.tex}
\input{sections/gaussianElimination.tex}
\input{sections/luDecomposition.tex}
\input{sections/lltCholesky.tex}
\input{sections/ldltCholesky.tex}
\input{sections/qrHouseholder.tex}




\section{Inverse Matrix}
\label{sec:InverseMatrix}

\section{Full factorization}
\label{sec:fullFactorization}

\section{Pivoting}
\label{sec:pivoting}


\section{Solver comparison}
\label{sec:solverSelection}

\end{document}
