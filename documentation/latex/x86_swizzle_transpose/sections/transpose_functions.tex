\section{Transpose functions}

\subsection{Introduction}
Transposing a matrix that uses an array of fundamental scalar types (\cppInline{int}, \cppInline{float}, \cppInline{double}, etc.) as underlying data structure is rather easy to implement.
For an arbitrary $M \times N$ matrix the implementation could look like the following piece of code:

\begin{minted}{cpp}
for (U32 i = 0; i < N; ++i)
    for (U32 j = 0; j < M; ++j)
        transposed[j + i * cols] = original[i + j * rows];
\end{minted}

If an array of vector register types (\cppInline{__m128},\cppInline{__m128d}, \cppInline{__m256}, etc.) is utilized to store the matrix's data, it gets more complicated.
This section describes the special transpose functions for x86 registers and how they can be used.
Additionally, some details of the implementation are discussed.

\subsection{Matrix format}
\label{sec:transpose_matrix_format}
In this section, we consider only matrices that are stored in column-major format and with a maximum size of $\numRegisterElements \times \numRegisterElements$, where $\numRegisterElements$ is the number of elements of the underlying register type.
By using $\numRegisterElements \times \numRegisterElements$ matrices as basic building blocks, any larger $M \times N$ matrix can be transposed by using the following rule:

\begin{align}
M =
\begin{bmatrix}
A_{11} & A_{12} & \cdots & A_{1j}\\
A_{21} & A_{22} & \cdots & A_{2j}\\
\vdots & \vdots & \ddots &\vdots \\
A_{i1} & A_{i2} & \cdots & A_{ij}\\
\end{bmatrix} && 
M^T =
\begin{bmatrix}
A_{11}^T & A_{21}^T & \cdots & A_{i1}^T\\
A_{12}^T & A_{22}^T & \cdots & A_{i2}^T\\
\vdots   & \vdots   & \ddots &\vdots \\
A_{1j}^T & A_{2j}^T & \cdots & A_{ij}^T\\
\end{bmatrix}  
\end{align}

\noindent Here all $A$ are $\numRegisterElements \times \numRegisterElements$ sub-matrices.


Each column of a matrix is stored in its own register.
This does not change, even if that means that some memory is wasted in case a matrix has less than $\numRegisterElements$ rows.
So an $2 \times 2$ matrix that is stored in an array of \cppInline{__m128} registers (4 elements per register) will still use 2 registers (one for each column), even though the data fits into a single one.

Additionally, the first row of a matrix with less than $\numRegisterElements$ rows mustn't necessarily be stored inside the first elements of the column registers. 
The only condition is that each column of the matrix is stored contiguously in ascending order and the offset is identical in each register of the matrix.
While one should usually avoid storing individual matrices with offsets, this gets important if only a sub-matrix of a $\numRegisterElements \times \numRegisterElements$ matrix should be transposed.
 

\subsection{Available functions}

\subsubsection{Specific transpose functions}

Each register type has its own set of transpose functions available in a corresponding header.
For example, for \cppInline{__m128} registers, you have to use
\begin{minted}{cpp}
#include "gdl/base/simd/_transpose/transpose_m128.h"
\end{minted}

The headers contain one function for each matrix size up to $\numRegisterElements \times \numRegisterElements$.
They are named ''Transpose'' plus the matrix size.
So for a $2 \times 4$ matrix, the function \cppInline{Transpose2x4} has to be used.

The functions only take registers of the utilized type as parameters.
Their number depends on the matrix size and is equal to the number of columns plus the number of rows.
The first $N$ parameters are the columns register of the $M \times N$ source matrix in ascending order.
The last $M$ parameters are references to the columns register of the $N \times M$ target matrix in ascending order.
Results of the transposition will be written directly to the passed registers of the target matrix.
Therefore, the functions do not return anything.

Furthermore, each function takes 4 optional template parameters.
The first parameter must be an integer that specifies the offset of the source matrix's first row inside its column registers (see \cref{sec:transpose_matrix_format}).
Default value is 0.
The second template parameter is also an integer and specifies the register offset of the target matrix's first row (default is 0).
Using these 2 parameters lets you read a sub-matrix at an arbitrary position of the source matrix and write the transposed result to an arbitrary location of a target matrix.

The third template parameter is a \cppInline{bool}.
Setting it to \cppInline{false} prevents the function from modifying any memory of the target matrix registers that is not needed to store the result of the transposition.
However, it is faster to use \cppInline{true} (default) since the limited set of swizzle operations requires additional blending instructions to keep values that shouldn't be modified in place.
In this case, the memory outside the result matrix's memory range usually contains meaningless garbage.
Make sure to only select \cppInline{false} as third template parameter if it is really necessary to get the best performance.

The fourth and last parameter is also a \cppInline{bool}.
It has only a meaning if the third parameter is set to \cppInline{true}.
By setting it to \cppInline{true}, all unused memory of the result registers is overwritten with 0.
In most cases, this requires additional instruction. 
Only the \cppInline{__m128} register has some functions where this is not the case due to the utilization of the \cppInline{Insert} function.
So this should always be set to \cppInline{false} (default) if it is not needed.

\subsubsection*{Examples}

The following examples show the Transposition of $3 \times 2$ matrix $\textrm{A}$ using different template parameter combinations. 
Its underlying data is the \cppInline{std::array<__m256, 2> a}.
The $2 \times 3$ result matrix $\textrm{B}$ has the \cppInline{std::array<__m256, 3> b} as underlying data structure.
Each register of the arrays contains a single matrix column as defined in \cref{sec:transpose_matrix_format}.

Since a single \cppInline{__m256} register contains 8 values, the matrix $\textrm{A}$ is actually visualized as an $8 \times 2$ matrix.
The relevant $3 \times 2$ block is marked in blue.

Similarly, the matrix $\textrm{B}$ is visualized twice as a $8 \times 3$ matrix.
Once before and once after the transposition.
The target area that receives the result values is marked green.
In case that values of $\textrm{B}$ are overwritten, even though they are not part of the result matrix, they are marked in red.
An $\times$ in $\textrm{B}$ after the transposition means that the corresponding value is undefined/random.


\vspace{1cm}
\begin{minipage}{\linewidth}
\begin{minted}{cpp}
Transpose3x2(a[0], a[1], b[0], b[1], b[2]);
\end{minted}
or 
\begin{minted}{cpp}
Transpose3x2<0 ,0 , true, false>(a[0], a[1], b[0], b[1], b[2]);
\end{minted}
yields:

\begin{align*}
\begin{matrix}
\textrm{Matrix A} & \textrm{Matrix B}  & & \textrm{Matrix B}\\
&\textrm{(before transposition)}&&\textrm{(after transposition)}\\
\\
\left(\begin{array}{cc}
\colSrc 0 & \colSrc 8\\
\colSrc 1 & \colSrc 9\\
\colSrc 2 & \colSrc 10\\
3 & 11\\
4 & 12\\
5 & 13\\
6 & 14\\
7 & 15
\end{array}\right) 
&
\left(\begin{array}{ccc}
\colTgt 100 & \colTgt 108 & \colTgt 116\\
\colTgt 101 & \colTgt 109 & \colTgt 117\\
\colOwr 102 & \colOwr 110 & \colOwr 118\\
\colOwr 103 & \colOwr 111 & \colOwr 119\\
\colOwr 104 & \colOwr 112 & \colOwr 120\\
\colOwr 105 & \colOwr 113 & \colOwr 121\\
\colOwr 106 & \colOwr 114 & \colOwr 122\\
\colOwr 107 & \colOwr 115 & \colOwr 123
\end{array}\right) 
&&
\left(\begin{array}{ccc}
0 & 1 & 2\\
8 & 9 & 10\\
\times & \times & \times\\
\times & \times & \times\\
\times & \times & \times\\
\times & \times & \times\\
\times & \times & \times\\
\times & \times & \times\\
\end{array}\right) 
\end{matrix}
\end{align*}
\end{minipage}


\vspace{2cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
Transpose3x2<4 ,2 , true, true>(a[0], a[1], b[0], b[1], b[2]);
	\end{minted}
	yields:
	\begin{align*}
	\begin{matrix}
	\textrm{Matrix A} & \textrm{Matrix B}  & & \textrm{Matrix B}\\
	&\textrm{(before transposition)}&&\textrm{(after transposition)}\\
	\\
	\left(\begin{array}{cc}
	0 & 8\\
	1 & 9\\
	2 & 10\\
	3 & 11\\
	\colSrc 4 & \colSrc 12\\
	\colSrc 5 & \colSrc 13\\
	\colSrc 6 & \colSrc 14\\
	7 & 15
	\end{array}\right) 
	&
	\left(\begin{array}{ccc}
	\colOwr 100 & \colOwr 108 & \colOwr 116\\
	\colOwr 101 & \colOwr 109 & \colOwr 117\\
	\colTgt 102 & \colTgt 110 & \colTgt 118\\
	\colTgt 103 & \colTgt 111 & \colTgt 119\\
	\colOwr 104 & \colOwr 112 & \colOwr 120\\
	\colOwr 105 & \colOwr 113 & \colOwr 121\\
	\colOwr 106 & \colOwr 114 & \colOwr 122\\
	\colOwr 107 & \colOwr 115 & \colOwr 123
	\end{array}\right) 
	&&
	\left(\begin{array}{ccc}
	0 & 0 & 0\\
	0 & 0 & 0\\
	4 & 5 & 6\\
	12 & 13 & 14\\
	0 & 0 & 0\\
	0 & 0 & 0\\
	0 & 0 & 0\\
	0 & 0 & 0	
	\end{array}\right) 
	\end{matrix}
	\end{align*}
\end{minipage}

\vspace{2cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
Transpose3x2<1 ,6 , false, false>(a[0], a[1], b[0], b[1], b[2]);
	\end{minted}
	yields:
	\begin{align*}
	\begin{matrix}
	\textrm{Matrix A} & \textrm{Matrix B}  & & \textrm{Matrix B}\\
	&\textrm{(before transposition)}&&\textrm{(after transposition)}\\
	\\
	\left(\begin{array}{cc}
	0 & 8\\
	\colSrc 1 & \colSrc 9\\
	\colSrc 2 & \colSrc 10\\
	\colSrc 3 & \colSrc 11\\
	4 & 12\\
    5 & 13\\
	6 & 14\\
	7 & 15
	\end{array}\right) 
	&
	\left(\begin{array}{ccc}
	100 & 108 & 116\\
	101 & 109 & 117\\
	102 & 110 & 118\\
	103 & 111 & 119\\
	104 & 112 & 120\\
	105 & 113 & 121\\
	\colTgt 106 & \colTgt 114 & \colTgt 122\\
	\colTgt 107 & \colTgt 115 & \colTgt 123
	\end{array}\right) 
	&&
	\left(\begin{array}{ccc}
    100 & 108 & 116\\
    101 & 109 & 117\\
    102 & 110 & 118\\
    103 & 111 & 119\\
    104 & 112 & 120\\
    105 & 113 & 121\\
    1 & 2 & 3\\
    9 & 10 & 11
\end{array}\right) 
	\end{matrix}
	\end{align*}
\end{minipage}

\subsubsection{General transpose function}


\subsection{Implementation details}
The challenge is to find the most effective combination of swizzle instructions (see previous section) to perform the transposition.
Unfortunately, the optimal combination depends on the matrix size.

