\section{Transpose functions}

\subsection{Introduction}
Transposing a matrix that uses an array of fundamental scalar types (\cppInline{int}, \cppInline{float}, \cppInline{double}, etc.) as underlying data structure is rather easy to implement.
For an arbitrary $M \times N$ matrix the implementation could look like the following piece of code:

\begin{minted}{cpp}
for (U32 i = 0; i < N; ++i)
    for (U32 j = 0; j < M; ++j)
        transposed[j + i * cols] = original[i + j * rows];
\end{minted}

If an array of vector register types (\cppInline{__m128},\cppInline{__m128d}, \cppInline{__m256}, etc.) is utilized to store the matrix's data, it gets more complicated.
This section describes the special transpose functions for x86 registers and how they can be used.
Additionally, some details of the implementation are discussed.

\subsection{Matrix format}
\label{sec:transpose_matrix_format}
In this section, we consider only matrices that are stored in column-major format and with a maximum size of $\numRegisterElements \times \numRegisterElements$, where $\numRegisterElements$ is the number of elements of the underlying register type.
By using $\numRegisterElements \times \numRegisterElements$ matrices as basic building blocks, any larger $M \times N$ matrix can be transposed by using the following rule:

\begin{align}
\label{eq:block_matrix_transpose}
M =
\begin{bmatrix}
A_{11} & A_{12} & \cdots & A_{1j}\\
A_{21} & A_{22} & \cdots & A_{2j}\\
\vdots & \vdots & \ddots &\vdots \\
A_{i1} & A_{i2} & \cdots & A_{ij}\\
\end{bmatrix} && 
M^T =
\begin{bmatrix}
A_{11}^T & A_{21}^T & \cdots & A_{i1}^T\\
A_{12}^T & A_{22}^T & \cdots & A_{i2}^T\\
\vdots   & \vdots   & \ddots &\vdots \\
A_{1j}^T & A_{2j}^T & \cdots & A_{ij}^T\\
\end{bmatrix}  
\end{align}

\noindent Here all $A$ are $\numRegisterElements \times \numRegisterElements$ sub-matrices.


Each column of a matrix is stored in its own register.
This does not change, even if that means that some memory is wasted in case a matrix has less than $\numRegisterElements$ rows.
So an $2 \times 2$ matrix that is stored in an array of \cppInline{__m128} registers (4 elements per register) will still use 2 registers (one for each column), even though the data fits into a single one.

Additionally, the first row of a matrix with less than $\numRegisterElements$ rows mustn't necessarily be stored inside the first elements of the column registers. 
The only condition is that each column of the matrix is stored contiguously in ascending order and the offset is identical in each register of the matrix.
While one should usually avoid storing individual matrices with offsets, this gets important if only a sub-matrix of a $\numRegisterElements \times \numRegisterElements$ matrix should be transposed.
 

\subsection{Available functions}

\subsubsection{Size specific functions}
\label{sec:size_specific_transpose_function}


Each register type has its own set of transpose functions available in a corresponding header.
For example, for \cppInline{__m128} registers, you have to use
\begin{minted}{cpp}
#include "gdl/base/simd/_transpose/transpose_m128.h"
\end{minted}

The headers contain one function for each matrix size up to $\numRegisterElements \times \numRegisterElements$.
They are named ''Transpose'' plus the matrix size.
So for a $2 \times 4$ matrix, the function \cppInline{Transpose2x4} has to be used.

The functions only take registers of the utilized type as parameters.
Their number depends on the matrix size and is equal to the number of columns plus the number of rows.
The first $N$ parameters are the columns register of the $M \times N$ source matrix in ascending order.
The last $M$ parameters are references to the columns register of the $N \times M$ target matrix in ascending order.
Results of the transposition will be written directly to the passed registers of the target matrix.
Therefore, the functions do not return anything.

Furthermore, each function takes 4 optional template parameters.
The first parameter must be an integer that specifies the offset of the source matrix's first row inside its column registers (see \cref{sec:transpose_matrix_format}).
Default value is 0.
The second template parameter is also an integer and specifies the register offset of the target matrix's first row (default is 0).
Using these 2 parameters lets you read a sub-matrix at an arbitrary position of the source matrix and write the transposed result to an arbitrary location of a target matrix.

The third template parameter is a \cppInline{bool}.
Setting it to \cppInline{false} prevents the function from modifying any memory of the target matrix registers that is not needed to store the result of the transposition.
However, it is faster to use \cppInline{true} (default) since the limited set of swizzle operations requires additional blending instructions to keep values that shouldn't be modified in place.
In this case, the memory outside the result matrix's memory range usually contains meaningless garbage.
Make sure to only select \cppInline{false} as third template parameter if it is really necessary to get the best performance.

The fourth and last parameter is also a \cppInline{bool}.
It has only a meaning if the third parameter is set to \cppInline{true}.
By setting it to \cppInline{true}, all unused memory of the result registers is overwritten with 0.
In most cases, this requires additional instruction. 
Only the \cppInline{__m128} register has some functions where this is not the case due to the utilization of the \cppInline{Insert} function.
So this should always be set to \cppInline{false} (default) if it is not needed.

\subsubsection*{Examples}

The following examples show the Transposition of $3 \times 2$ matrix $\textrm{A}$ using different template parameter combinations. 
Its underlying data is the \cppInline{std::array<__m256, 2> a}.
The $2 \times 3$ result matrix $\textrm{B}$ has the \cppInline{std::array<__m256, 3> b} as underlying data structure.
Each register of the arrays contains a single matrix column as defined in \cref{sec:transpose_matrix_format}.

Since a single \cppInline{__m256} register contains 8 values, the matrix $\textrm{A}$ is actually visualized as an $8 \times 2$ matrix.
The relevant $3 \times 2$ block is marked in blue.

Similarly, the matrix $\textrm{B}$ is visualized twice as a $8 \times 3$ matrix.
Once before and once after the transposition.
The target area that receives the result values is marked green.
In case that values of $\textrm{B}$ are overwritten, even though they are not part of the result matrix, they are marked in red.
An ''$\times$'' in $\textrm{B}$ after the transposition means that the corresponding value is undefined/random.


\vspace{1cm}
\begin{minipage}{\linewidth}
\begin{minted}{cpp}
Transpose3x2(a[0], a[1], b[0], b[1], b[2]);
\end{minted}
equivalent to: 
\begin{minted}{cpp}
Transpose3x2<0 ,0 , true, false>(a[0], a[1], b[0], b[1], b[2]);
\end{minted}
yields:

\begin{align*}
\begin{matrix}
\textrm{Matrix A} & \textrm{Matrix B}  & & \textrm{Matrix B}\\
&\textrm{(before transposition)}&&\textrm{(after transposition)}\\
\\
\left(\begin{array}{cc}
\colSrc 0 & \colSrc 8\\
\colSrc 1 & \colSrc 9\\
\colSrc 2 & \colSrc 10\\
3 & 11\\
4 & 12\\
5 & 13\\
6 & 14\\
7 & 15
\end{array}\right) 
&
\left(\begin{array}{ccc}
\colTgt 100 & \colTgt 108 & \colTgt 116\\
\colTgt 101 & \colTgt 109 & \colTgt 117\\
\colOwr 102 & \colOwr 110 & \colOwr 118\\
\colOwr 103 & \colOwr 111 & \colOwr 119\\
\colOwr 104 & \colOwr 112 & \colOwr 120\\
\colOwr 105 & \colOwr 113 & \colOwr 121\\
\colOwr 106 & \colOwr 114 & \colOwr 122\\
\colOwr 107 & \colOwr 115 & \colOwr 123
\end{array}\right) 
&&
\left(\begin{array}{ccc}
0      & 1      & 2\\
8      & 9      & 10\\
\times & \times & \times\\
\times & \times & \times\\
\times & \times & \times\\
\times & \times & \times\\
\times & \times & \times\\
\times & \times & \times\\
\end{array}\right) 
\end{matrix}
\end{align*}
\end{minipage}


\vspace{2cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
Transpose3x2<4 ,2 , true, true>(a[0], a[1], b[0], b[1], b[2]);
	\end{minted}
	yields:
	\begin{align*}
	\begin{matrix}
	\textrm{Matrix A} & \textrm{Matrix B}  & & \textrm{Matrix B}\\
	&\textrm{(before transposition)}&&\textrm{(after transposition)}\\
	\\
	\left(\begin{array}{cc}
	0 & 8\\
	1 & 9\\
	2 & 10\\
	3 & 11\\
	\colSrc 4 & \colSrc 12\\
	\colSrc 5 & \colSrc 13\\
	\colSrc 6 & \colSrc 14\\
	7 & 15
	\end{array}\right) 
	&
	\left(\begin{array}{ccc}
	\colOwr 100 & \colOwr 108 & \colOwr 116\\
	\colOwr 101 & \colOwr 109 & \colOwr 117\\
	\colTgt 102 & \colTgt 110 & \colTgt 118\\
	\colTgt 103 & \colTgt 111 & \colTgt 119\\
	\colOwr 104 & \colOwr 112 & \colOwr 120\\
	\colOwr 105 & \colOwr 113 & \colOwr 121\\
	\colOwr 106 & \colOwr 114 & \colOwr 122\\
	\colOwr 107 & \colOwr 115 & \colOwr 123
	\end{array}\right) 
	&&
	\left(\begin{array}{ccc}
	0 & 0 & 0\\
	0 & 0 & 0\\
	4 & 5 & 6\\
	12 & 13 & 14\\
	0 & 0 & 0\\
	0 & 0 & 0\\
	0 & 0 & 0\\
	0 & 0 & 0	
	\end{array}\right) 
	\end{matrix}
	\end{align*}
\end{minipage}

\vspace{2cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
Transpose3x2<1 ,6 , false, false>(a[0], a[1], b[0], b[1], b[2]);
	\end{minted}
	yields:
	\begin{align*}
	\begin{matrix}
	\textrm{Matrix A} & \textrm{Matrix B}  & & \textrm{Matrix B}\\
	&\textrm{(before transposition)}&&\textrm{(after transposition)}\\
	\\
	\left(\begin{array}{cc}
	0 & 8\\
	\colSrc 1 & \colSrc 9\\
	\colSrc 2 & \colSrc 10\\
	\colSrc 3 & \colSrc 11\\
	4 & 12\\
    5 & 13\\
	6 & 14\\
	7 & 15
	\end{array}\right) 
	&
	\left(\begin{array}{ccc}
	100 & 108 & 116\\
	101 & 109 & 117\\
	102 & 110 & 118\\
	103 & 111 & 119\\
	104 & 112 & 120\\
	105 & 113 & 121\\
	\colTgt 106 & \colTgt 114 & \colTgt 122\\
	\colTgt 107 & \colTgt 115 & \colTgt 123
	\end{array}\right) 
	&&
	\left(\begin{array}{ccc}
    100 & 108 & 116\\
    101 & 109 & 117\\
    102 & 110 & 118\\
    103 & 111 & 119\\
    104 & 112 & 120\\
    105 & 113 & 121\\
    1 & 2 & 3\\
    9 & 10 & 11
\end{array}\right) 
	\end{matrix}
	\end{align*}
\end{minipage}

\subsubsection{General purpose function}
\label{sec:general_transpose_function}

Having a separate transpose function for each matrix size limits flexibility.
The general purpose function wraps all size and register specific transpose functions into a large compile time switch that can be controlled by the functions template parameters.
It can be included with:

\begin{minted}{cpp}
#include "gdl/base/simd/transpose.h"
\end{minted}

Instead of passing each of the matrices' underlying registers separately, the source matrix data and the target matrix data are both passed as a \cppInline{std::array} of the corresponding register type.
The minimal size of the array must fulfill the storage requirements of the matrix format defined in \cref{sec:transpose_matrix_format}, but it might also be larger.
Special offset and stride template parameters can be used to select the registers that belong to the source and target matrix inside arbitrary over-sized arrays.
This functionality can be used to transpose matrices of any size that are stored inside a continuous register array by using \cref{eq:block_matrix_transpose}.

The function has 10 template parameter options to modify its behavior.
The matrix size is selected with the first 2 parameters, with the number of rows being the first parameter.
If the selected size exceeds the register specific limitations, a corresponding static assertion will fail.
Parameter 3 and 4 define the offsets of the source and target matrix's first row inside their corresponding registers (see \cref{sec:transpose_matrix_format}).
They are internally past as the first two template parameters to the corresponding size specific function.
The default value is 0.
The parameters 5 and 6 specify the index of the matrices first column registers inside their corresponding data array (default 0).
Parameter 7 and 8 are the stride between to matrix registers inside the data arrays (default 1).
The last 2 parameters are Boolean switches that specify how register memory of the target matrix is handled, that is not needed to store the result.
Their order, default values and functionality are identical to the third and fourth template parameter of the size specific functions described in the previous section.


\subsubsection*{Examples}

The following examples show different applications of the general purpose \cppInline{Transpose} function.
The arrays \cppInline{std::array<__m256, 6> a} and \cppInline{std::array<__m256, 5> b} will be used as input parameters. 
They are visualized as a matrix, where each column represents a single register.
As in the previous section, the array \cppInline{b} will be shown before and after the operation.
Areas colored in blue mark the source values in the array \cppInline{a}.
Entries of the array \cppInline{b}, that will be overwritten by the result matrix, are colored green.
Red areas mark values that are not part of the result matrix but will be overwritten by the function.
An $\times$ in the representation of \cppInline{b} after the transposition represents an undefined value (random value from the source matrix).

\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
Transpose<3, 2>(a, b);
	\end{minted}
	equivalent to: 
	\begin{minted}{cpp}
Transpose<3, 2, 0, 0, 0, 0, 1, 1, true, false>(a, b);
	\end{minted}
	yields:
	
	\begin{align*}
	\begin{matrix}
	\textrm{array a} & \textrm{array b}  & & \textrm{array b}\\
	&\textrm{(before transposition)}&&\textrm{(after transposition)}\\
	\\
	\left(\begin{array}{cccccc}
	\colSrc 0 & \colSrc 8  & 16 & 24 & 32 & 40\\
	\colSrc 1 & \colSrc 9  & 17 & 25 & 33 & 41\\
	\colSrc 2 & \colSrc 10 & 18 & 26 & 34 & 42\\
	3 & 11 & 19 & 27 & 35 & 43\\
    4 & 12 & 20 & 28 & 36 & 44\\
    5 & 13 & 21 & 29 & 37 & 45\\
    6 & 14 & 22 & 30 & 38 & 46\\
    7 & 15 & 23 & 31 & 39 & 47
	\end{array}\right) 
	&
	\left(\begin{array}{ccccc}
	\colTgt 60 & \colTgt 68 & \colTgt 76 & 84 & 92\\
	\colTgt 61 & \colTgt 69 & \colTgt 77 & 85 & 93\\
	\colOwr 62 & \colOwr 70 & \colOwr 78 & 86 & 94\\
	\colOwr 63 & \colOwr 71 & \colOwr 79 & 87 & 95\\
	\colOwr 64 & \colOwr 72 & \colOwr 80 & 88 & 96\\
	\colOwr 65 & \colOwr 73 & \colOwr 81 & 89 & 97\\
	\colOwr 66 & \colOwr 74 & \colOwr 82 & 90 & 98\\
	\colOwr 67 & \colOwr 75 & \colOwr 83 & 91 & 99
	\end{array}\right) 
	&&
	\left(\begin{array}{ccccc}
	0      & 1      & 2      & 84 & 92\\
	8      & 9      & 10     & 85 & 93\\
	\times & \times & \times & 86 & 94\\
	\times & \times & \times & 87 & 95\\
	\times & \times & \times & 88 & 96\\
	\times & \times & \times & 89 & 97\\
	\times & \times & \times & 90 & 98\\
	\times & \times & \times & 91 & 99
	\end{array}\right)
	\end{matrix}
	\end{align*}
\end{minipage}



\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
Transpose<2, 2, 6, 3, 2, 1, 1, 1, true, true>(a, b);
	\end{minted}
	yields:
	
	\begin{align*}
	\begin{matrix}
	\textrm{array a} & \textrm{array b}  & & \textrm{array b}\\
	&\textrm{(before transposition)}&&\textrm{(after transposition)}\\
	\\
	\left(\begin{array}{cccccc}
	0 & 8  & 16         & 24         & 32 & 40\\
	1 & 9  & 17         & 25         & 33 & 41\\
	2 & 10 & 18         & 26         & 34 & 42\\
	3 & 11 & 19         & 27         & 35 & 43\\
	4 & 12 & 20         & 28         & 36 & 44\\
	5 & 13 & 21         & 29         & 37 & 45\\
	6 & 14 & \colSrc 22 & \colSrc 30 & 38 & 46\\
	7 & 15 & \colSrc 23 & \colSrc 31 & 39 & 47
	\end{array}\right) 
	&
	\left(\begin{array}{ccccc}
	60 & \colOwr 68 & \colOwr 76 & 84 & 92\\
	61 & \colOwr 69 & \colOwr 77 & 85 & 93\\
	62 & \colOwr 70 & \colOwr 78 & 86 & 94\\
	63 & \colTgt 71 & \colTgt 79 & 87 & 95\\
	64 & \colTgt 72 & \colTgt 80 & 88 & 96\\
	65 & \colOwr 73 & \colOwr 81 & 89 & 97\\
	66 & \colOwr 74 & \colOwr 82 & 90 & 98\\
	67 & \colOwr 75 & \colOwr 83 & 91 & 99
	\end{array}\right) 
	&&
	\left(\begin{array}{ccccc}
	60 & 0  & 0  & 84 & 92\\
	61 & 0  & 0  & 85 & 93\\
	62 & 0  & 0  & 86 & 94\\
	63 & 22 & 23 & 87 & 95\\
	64 & 30 & 31 & 88 & 96\\
	65 & 0  & 0  & 89 & 97\\
	66 & 0  & 0  & 90 & 98\\
	67 & 0  & 0  & 91 & 99
	\end{array}\right)
	\end{matrix}
	\end{align*}
\end{minipage}



\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
	Transpose<2, 3, 1, 3, 0, 1, 2, 3, false, false>(a, b);
	\end{minted}
	yields:
	
	\begin{align*}
	\begin{matrix}
	\textrm{array a} & \textrm{array b}  & & \textrm{array b}\\
	&\textrm{(before transposition)}&&\textrm{(after transposition)}\\
	\\
	\left(\begin{array}{cccccc}
	0         & 8  & 16         & 24 & 32         & 40\\
	\colSrc 1 & 9  & \colSrc 17 & 25 & \colSrc 33 & 41\\
	\colSrc 2 & 10 & \colSrc 18 & 26 & \colSrc 34 & 42\\
	3         & 11 & 19         & 27 & 35         & 43\\
	4         & 12 & 20         & 28 & 36         & 44\\
	5         & 13 & 21         & 29 & 37         & 45\\
	6         & 14 & 22         & 30 & 38         & 46\\
	7         & 15 & 23         & 31 & 39         & 47
	\end{array}\right) 
	&
	\left(\begin{array}{ccccc}
	60 & 68         & 76 & 84 & 92\\
	61 & 69         & 77 & 85 & 93\\
	62 & 70         & 78 & 86 & 94\\
	63 & \colTgt 71 & 79 & 87 & \colTgt 95\\
	64 & \colTgt 72 & 80 & 88 & \colTgt 96\\
	65 & \colTgt 73 & 81 & 89 & \colTgt 97\\
	66 & 74         & 82 & 90 & 98\\
	67 & 75         & 83 & 91 & 99
	\end{array}\right) 
	&&
	\left(\begin{array}{ccccc}
	60 & 68 & 76 & 84 & 92\\
	61 & 69 & 77 & 85 & 93\\
	62 & 70 & 78 & 86 & 94\\
	63 & 1  & 79 & 87 & 2\\
	64 & 17 & 80 & 88 & 18\\
	65 & 33 & 81 & 89 & 34\\
	66 & 74 & 82 & 90 & 98\\
	67 & 75 & 83 & 91 & 99
	\end{array}\right)
	\end{matrix}
	\end{align*}
\end{minipage}



\subsection{Implementation details for multi-lane registers}

The provided option to select where the first input and output matrix row is located inside the underlying registers requires a significant amount of extra code. 
The reason for this is that the correct set of swizzle instructions is more or less unique for each parameter combination.
The correct instruction set is selected at compile time using \cppInline{if constexpr}.
There are some patterns that can be shared between multiple parameter sets, but usually they are hard to figure out before every case has been written down.

To the author's knowledge, there are no general rules or patterns that can be used to simplify and speedup the implementation of matrices based on single lane register types.
However, for multi-lane registers \cref{eq:block_matrix_transpose} can be used to heavily reuse code in larger matrices as will be shown in the following sections.


\subsubsection{Swizzling across lane boundaries}

Transposing matrices composed of multi lane registers requires to swizzle values across lane boundaries in most cases.
It was already mentioned in previous sections that such operations are somewhat more expensive than in-lane swizzling.


The reason for this is the comparatively high latency of the \cppInline{_mm256_permute2f128_ps} and \cppInline{_mm256_permute2f128_pd} instructions.
On a Skylake architecture, it takes 3 processor cycles to calculate the result while most inter-lane operations can be processed in a single cycle.
However, the throughput is 1 (Skylake), which is equivalent to most of the other swizzle operations. 
This means that a single operation can be started per cycle as long as there are no dependencies on results of currently running operations.
In conclusion, the overhead of inter lane permutations can be reduced to just 2 extra cycles if they are all processed successively and without depending on each other.
The techniques described in \cref{sec:Implementation_4x4_matrices,sec:Implementation_general_multi_lane_matrices} show possible approaches to accomplish this.



\subsubsection{4x4 single precision matrices}
\label{sec:Implementation_4x4_matrices}

The techniques described in this section focus on the \cppInline{__m256} register type and $4 \times 4$ matrices.
Even though the text might be very specific, the introduced approaches can be easily transferred to multi lane registers of different size (\cppInline{__m512}) and base type (\cppInline{__m256d}, \cppInline{__m512d} - using $2 \times 2$ matrices).

The transposition of a $4 \times 4$ matrix based on the \cppInline{__m256} register type marks a special case for the representation described in \cref{sec:transpose_matrix_format} since its number of rows and columns equals the size of a register lane.
As consequence, it is the largest matrix that has certain parameter combinations that do not require permutations across lane boundaries.
This is the case if the row offset of input and output matrix is identical and all data is stored in the same lane.
For the functions described in \cref{sec:size_specific_transpose_function,sec:general_transpose_function} this happens for the offset combinations $0/0$ and $4/4$.
A possible instruction set that performs this operation is the following:

\begin{minted}{cpp}
__m256 tmp_0 = _mm_unpacklo(a[0], a[1]);
__m256 tmp_1 = _mm_unpackhi(a[0], a[1]);
__m256 tmp_2 = _mm_unpacklo(a[2], a[3]);
__m256 tmp_3 = _mm_unpackhi(a[2], a[3]);

b[0] = _mm_movelh(tmp_0, tmp_2);
b[1] = _mm_movehl(tmp_2, tmp_0);
b[2] = _mm_movelh(tmp_1, tmp_3);
b[3] = _mm_movehl(tmp_3, tmp_1);
\end{minted}

The shown instructions only perform swizzle operations that affect each lane in the same way.
Therefore, \cppInline{Transpose<4, 4, 0, 0>(a, b);} and \cppInline{Transpose<4, 4, 4, 4>(a, b);} will write the exact same values to \cppInline{b}.
Here is a visualization of the arrays' contents:

\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
Transpose<4, 4, 0, 0>(a, b);
	\end{minted}
	yields:
	
	\begin{align*}
	\begin{matrix}
	\textrm{array a} &&& \textrm{array b}\\
    &&&\textrm{(after transposition)}\\
	\\
	\left(\begin{array}{cccc}
	\col{0} 0 & \col{4} 8  & \col{8}  16 & \col{12} 24 \\
	\col{1} 1 & \col{5} 9  & \col{9}  17 & \col{13} 25 \\
	\col{2} 2 & \col{6} 10 & \col{10} 18 & \col{14} 26 \\
	\col{3} 3 & \col{7} 11 & \col{11} 19 & \col{15} 27 \\
	\hline
	4 & 12 & 20 & 28 \\	
	5 & 13 & 21 & 29 \\
	6 & 14 & 22 & 30 \\
	7 & 15 & 23 & 31 
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}
	\col{0}  0  & \col{1}   1 & \col{2}   2 & \col{3}   3 \\
	\col{4}  8  & \col{5}   9 & \col{6}  10 & \col{7}  11 \\
	\col{8}  16 & \col{9}  17 & \col{10} 18 & \col{11} 19 \\
	\col{12} 24 & \col{13} 25 & \col{14} 26 & \col{15} 27 \\
	\hline
	4  &  5 &  6 &  7 \\
	12 & 13 & 14 & 15 \\
	20 & 21 & 22 & 23 \\
	28 & 29 & 30 & 31 \\
	\end{array}\right)
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

The content of the array \cppInline{b} before the transposition is not relevant here since it is completely overwritten.
As you can see , the second lane of \cppInline{b} contains the transposed matrix of the second lane of \cppInline{a}.
Therefore, we can cover both cases with a single set of instructions.

Additionally, we can also cover the cases where the whole data of source and target matrix is contained inside a single register lane, but those lanes differ between both matrices.
To do so, one just needs to swap the lanes before or after the transposition.
For example:

\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
	Transpose<4, 4, 0, 4>(a, b);
	\end{minted}
	possible sub-steps:
	
	\begin{align*}
	\begin{matrix}
	\textrm{array a} &&& \textrm{array a}  &&& \textrm{array b}\\
	&&&\textrm{(swapped lanes)}&&&\textrm{(in-lane transposition)}\\
	\\
	\left(\begin{array}{cccc}
	\col{0} 0 & \col{4} 8  & \col{8}  16 & \col{12} 24 \\
    \col{1} 1 & \col{5} 9  & \col{9}  17 & \col{13} 25 \\
	\col{2} 2 & \col{6} 10 & \col{10} 18 & \col{14} 26 \\
	\col{3} 3 & \col{7} 11 & \col{11} 19 & \col{15} 27 \\
	\hline
	4 & 12 & 20 & 28 \\	
	5 & 13 & 21 & 29 \\
	6 & 14 & 22 & 30 \\
	7 & 15 & 23 & 31 
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}
	4 & 12 & 20 & 28 \\	
	5 & 13 & 21 & 29 \\
	6 & 14 & 22 & 30 \\
	7 & 15 & 23 & 31 \\
	\hline		
	\col{0} 0 & \col{4} 8  & \col{8}  16 & \col{12} 24 \\
	\col{1} 1 & \col{5} 9  & \col{9}  17 & \col{13} 25 \\
	\col{2} 2 & \col{6} 10 & \col{10} 18 & \col{14} 26 \\
	\col{3} 3 & \col{7} 11 & \col{11} 19 & \col{15} 27 \\
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}
	4  &  5 &  6 &  7 \\
	12 & 13 & 14 & 15 \\
	20 & 21 & 22 & 23 \\
	28 & 29 & 30 & 31 \\
	\hline
	\col{0}  0  & \col{1}   1 & \col{2}   2 & \col{3}   3 \\
	\col{4}  8  & \col{5}   9 & \col{6}  10 & \col{7}  11 \\
	\col{8}  16 & \col{9}  17 & \col{10} 18 & \col{11} 19 \\
	\col{12} 24 & \col{13} 25 & \col{14} 26 & \col{15} 27 \\
	\end{array}\right)
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

Until now, we have covered all possible permutations where the data of the input and output matrix is stored in a single lane with a common in-lane transposition instruction set.
We will now show step-by-step that this can be further reused for any combinations of input and output register offsets.

First, we consider the case where the input matrix's data is contained in a single register lane but the offset inside the result registers can be arbitrary.
All that needs to be done is to change the order of the input matrix's registers.
One simply moves the last register to the front and repeats this a number of times equal to the chosen offset.
Afterwards there are two variants how to proceed.
The first one is to swap all the lanes of the registers that contain data which will end up in a different lane and perform a ''no offset'' $4 \times 4$ transposition subsequently.
The second approach performs the ''no offset'' transposition first and then duplicates the relevant lanes.
Both variations, are visualized in the two examples below even though performing the inter-lane permutations before the transposition is beneficial since it requires less additional instructions (lane swaps/copies), saving some CPU cycles.
Notice that is not necessary to reorder the array \cppInline{a} if the size specific \cppInline{Transpose4x4} function is used internally.
Instead, can just vary the order of the functions' input registers.

\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
Transpose<4, 4, 0, 1>(a, b);
	\end{minted}
	possible sub-steps:
	
	\begin{align*}
	\begin{matrix}
	\textrm{array a}\\
	\\
	\left(\begin{array}{cccc}	
	\col{0} 0 & \col{4} 8  & \col{8}  16 & \col{12} 24 \\
	\col{1} 1 & \col{5} 9  & \col{9}  17 & \col{13} 25 \\
	\col{2} 2 & \col{6} 10 & \col{10} 18 & \col{14} 26 \\
	\col{3} 3 & \col{7} 11 & \col{11} 19 & \col{15} 27 \\
	\hline
	4 & 12 & 20 & 28 \\	
	5 & 13 & 21 & 29 \\
	6 & 14 & 22 & 30 \\
	7 & 15 & 23 & 31 
	\end{array}\right) 
	\\
	\\
	\\
	\textbf{Approach 1}\\
	\\
	\textrm{function input} &&& \textrm{tenporary data}  &&& \textrm{array b}\\
	\textrm{(right shift registers $\times 1$)}&&&\textrm{(swapped lanes)}&&&\textrm{(in-lane transposition)}\\
	\left(\begin{array}{cccc}
	\col{12} 24 & \col{0} 0 & \col{4} 8  & \col{8}  16 \\
	\col{13} 25 & \col{1} 1 & \col{5} 9  & \col{9}  17 \\
	\col{14} 26 & \col{2} 2 & \col{6} 10 & \col{10} 18 \\
	\col{15} 27 & \col{3} 3 & \col{7} 11 & \col{11} 19 \\
	\hline
	28 & 4 & 12 & 20 \\	
	29 & 5 & 13 & 21 \\
	30 & 6 & 14 & 22 \\
	31 & 7 & 15 & 23  
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}
	28 & \col{0} 0 & \col{4} 8  & \col{8}  16 \\
	29 & \col{1} 1 & \col{5} 9  & \col{9}  17 \\
	30 & \col{2} 2 & \col{6} 10 & \col{10} 18 \\
	31 & \col{3} 3 & \col{7} 11 & \col{11} 19 \\
	\hline
	\col{12} 24 & 4 & 12 & 20 \\	
	\col{13} 25 & 5 & 13 & 21 \\
	\col{14} 26 & 6 & 14 & 22 \\
	\col{15} 27 & 7 & 15 & 23  
	\end{array}\right) 
	&&&	
	\left(\begin{array}{cccc}	
	       28  &         29 &          30 &          31 \\
	\col{0} 0  & \col{1}  1 & \col{2}   2 & \col{3}   3 \\
	\col{4} 8  & \col{5}  9 & \col{6}  10 & \col{7}  11 \\
	\col{8} 16 & \col{9} 17 & \col{10} 18 & \col{11} 19 \\	
	\hline
	\col{12} 24 & \col{13} 25 & \col{14} 26 & \col{15} 27 \\
	          4 &           5 &           6 &           7 \\
	         12 &          13 &          14 &          15 \\
	         20 &          21 &          22 &          23 \\
	\end{array}\right)
	\\
	\\
	\\
	\textbf{Approach 2}\\
	\\
	\textrm{function input} &&& \textrm{tenporary data}  &&& \textrm{array b}\\
	\textrm{(right shift registers $\times 1$)}&&&\textrm{(in-lane transposition)}&&&\textrm{(copied lanes)}\\
	\left(\begin{array}{cccc}
	\col{12} 24 & \col{0} 0 & \col{4} 8  & \col{8}  16 \\
	\col{13} 25 & \col{1} 1 & \col{5} 9  & \col{9}  17 \\
	\col{14} 26 & \col{2} 2 & \col{6} 10 & \col{10} 18 \\
	\col{15} 27 & \col{3} 3 & \col{7} 11 & \col{11} 19 \\
	\hline
	28 & 4 & 12 & 20 \\	
	29 & 5 & 13 & 21 \\
	30 & 6 & 14 & 22 \\
	31 & 7 & 15 & 23  
	\end{array}\right) 
	&&&	
	\left(\begin{array}{cccc}
	\col{12} 24 & \col{13} 25 & \col{14} 26 & \col{15} 27 \\
	\col{0}  0  & \col{1}   1 & \col{2}   2 & \col{3}   3 \\
	\col{4}  8  & \col{5}   9 & \col{6}  10 & \col{7}  11 \\
	\col{8}  16 & \col{9}  17 & \col{10} 18 & \col{11} 19 \\	
	\hline	
	28 & 29 & 30 & 31 \\
	4  &  5 &  6 &  7 \\
	12 & 13 & 14 & 15 \\
	20 & 21 & 22 & 23 \\
	\end{array}\right)
	&&&	
	\left(\begin{array}{cccc}
	         24 &          25 &          26 &          27 \\
	\col{0}  0  & \col{1}   1 & \col{2}   2 & \col{3}   3 \\
	\col{4}  8  & \col{5}   9 & \col{6}  10 & \col{7}  11 \\
	\col{8}  16 & \col{9}  17 & \col{10} 18 & \col{11} 19 \\		
	\hline
	\col{12} 24 & \col{13} 25 & \col{14} 26 & \col{15} 27 \\
	         0  &           1 &           2 &           3 \\
	         8  &           9 &          10 &          11 \\
	         16 &          17 &          18 &         19 \\
	\end{array}\right)
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}


\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
Transpose<4, 4, 4, 2>(a, b);
	\end{minted}
	
	\begin{align*}
	\begin{matrix}
	\textrm{array a}\\
	\\
	\left(\begin{array}{cccc}
	0 & 8  & 16 & 24 \\
	1 & 9  & 17 & 25 \\
	2 & 10 & 18 & 26 \\
	3 & 11 & 19 & 27 \\
	\hline
	\col{0} 4 & \col{4} 12 & \col{8}  20 & \col{12} 28 \\	
	\col{1} 5 & \col{5} 13 & \col{9}  21 & \col{13} 29 \\
	\col{2} 6 & \col{6} 14 & \col{10} 22 & \col{14} 30 \\
	\col{3} 7 & \col{7} 15 & \col{11} 23 & \col{15} 31 
	\end{array}\right) 
	\\
	\\
	\\
	\textbf{Approach 1}\\
	\\
	\textrm{function input} &&& \textrm{tenporary data}  &&& \textrm{array b}\\
	\textrm{(right shift registers $\times 2$)}&&&\textrm{(swapped lanes)}&&&\textrm{(in-lane transposition)}\\
	\left(\begin{array}{cccc}
	16 & 24 & 0 & 8  \\
	17 & 25 & 1 & 9  \\
	18 & 26 & 2 & 10 \\
	19 & 27 & 3 & 11 \\
	\hline
	\col{8}  20 & \col{12} 28 & \col{0} 4 & \col{4} 12 \\	
	\col{9}  21 & \col{13} 29 & \col{1} 5 & \col{5} 13 \\
	\col{10} 22 & \col{14} 30 & \col{2} 6 & \col{6} 14 \\
	\col{11} 23 & \col{15} 31 & \col{3} 7 & \col{7} 15 
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}
	16 & 24 & \col{0} 4 & \col{4} 12  \\
	17 & 25 & \col{1} 5 & \col{5} 13  \\
	18 & 26 & \col{2} 6 & \col{6} 14  \\
	19 & 27 & \col{3} 7 & \col{7} 15  \\
	\hline
	\col{8}  20 & \col{12} 28 & 0 & 8  \\	
	\col{9}  21 & \col{13} 29 & 1 & 9  \\
	\col{10} 22 & \col{14} 30 & 2 & 10 \\
	\col{11} 23 & \col{15} 31 & 3 & 11 
	\end{array}\right) 
	&&&	
	\left(\begin{array}{cccc}	
	16         &         17 &         18 &         19 \\	
	24         &         25 &         26 &         27 \\
	\col{0} 4  & \col{1}  5 & \col{2}  6 & \col{3}  7 \\
	\col{4} 12 & \col{5} 13 & \col{6} 14 & \col{7} 15 \\
	\hline
	\col{8}  20 & \col{9}  21 & \col{10} 22 & \col{11} 23 \\
	\col{12} 28 & \col{13} 29 & \col{14} 30 & \col{15} 31 \\
	         0  &           1 &           2 &           3 \\
	         8  &           9 &          10 &          11 \\
	\end{array}\right)
	\\
	\\
	\\
	\textbf{Approach 2}\\
	\\
	\textrm{function input} &&& \textrm{tenporary data}  &&& \textrm{array b}\\
	\textrm{(right shift registers $\times 2$)}&&&\textrm{(in-lane transposition)}&&&\textrm{(copied lanes)}\\
	\left(\begin{array}{cccc}
	16 & 24 & 0 & 8  \\
	17 & 25 & 1 & 9  \\
	18 & 26 & 2 & 10 \\
	19 & 27 & 3 & 11 \\
	\hline
	\col{8}  20 & \col{12} 28 & \col{0} 4 & \col{4} 12 \\	
	\col{9}  21 & \col{13} 29 & \col{1} 5 & \col{5} 13 \\
	\col{10} 22 & \col{14} 30 & \col{2} 6 & \col{6} 14 \\
	\col{11} 23 & \col{15} 31 & \col{3} 7 & \col{7} 15  
	\end{array}\right) 
	&&&	
	\left(\begin{array}{cccc}
	16 & 17 & 18 & 19 \\
	24 & 25 & 26 & 27 \\
	 0 &  1 &  2 &  3 \\
	 8 &  9 & 10 & 11 \\	
	\hline
	\col{8}  20 & \col{9}  21 & \col{10} 22 & \col{11} 23 \\
	\col{12} 28 & \col{13} 29 & \col{14} 30 & \col{15} 31 \\
	\col{0}  4  & \col{1}   5 & \col{2}   6 & \col{3}   7 \\
	\col{4}  12 & \col{5}  13 & \col{6}  14 & \col{7}  15 \\
	\end{array}\right)
	&&&	
	\left(\begin{array}{cccc}
	         20 &          21 &          22 &          23 \\
	         28 &          29 &          30 &          31 \\
	\col{0}  4  & \col{1}   5 & \col{2}   6 & \col{3}   7 \\
	\col{4}  12 & \col{5}  13 & \col{6}  14 & \col{7}  15 \\
	\hline
	\col{8}  20 & \col{9}  21 & \col{10} 22 & \col{11} 23 \\
	\col{12} 28 & \col{13} 29 & \col{14} 30 & \col{15} 31 \\
	          4 &           5 &           6 &           7 \\
	         12 &          13 &          14 &          15 \\
	\end{array}\right)
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

The first depicted approach can also be imagined as the transposition of a $4 \times 8$ matrix if the values inside the second lane are moved to the right of the first lane. 
In this imaginary model, moving the last column in front of the first shifts every row in the transposed $8 \times 4$ result matrix one row down, except for the last one, which is now the first row.
So repeating this step multiple times enables us to move the transposed matrix to arbitrary offsets inside the result array.

Next, we will investigate the case where a $4 \times 4$ matrix with arbitrary offset is transposed and afterwards stored inside a single lane of the result array. 
The approach is quite similar as in the previous case, but instead of reordering the input array \cppInline{a} we need to reorder the result array \cppInline{b} by moving the first register to the end a number of times equal to the input arrays offset. Here are two visualized examples:


\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
Transpose<4, 4, 1, 0>(a, b);
	\end{minted}
	possible sub-steps:
	\begin{align*}
	\begin{matrix}
	\textrm{array a}\\
	\\
	\left(\begin{array}{cccc}	
	        0 &         8  &          16 &          24 \\
	\col{0} 1 & \col{4} 9  & \col{8}  17 & \col{12} 25 \\
	\col{1} 2 & \col{5} 10 & \col{9}  18 & \col{13} 26 \\
	\col{2} 3 & \col{6} 11 & \col{10} 19 & \col{14} 27 \\
	\hline
	\col{3} 4 & \col{7} 12 & \col{11} 20 & \col{15} 28 \\	
	        5 &         13 &          21 &          29 \\
	        6 &         14 &          22 &          30 \\
	        7 &         15 &          23 &          31 
	\end{array}\right) 
	\\
	\\
	\textrm{temporary data} &&& \textrm{temporary data}  &&& \textrm{array b}\\
	\textrm{(in-lane transposition)}&&&\textrm{(swapped lanes)}&&&\textrm{(left shift registers $\times 1$)}\\
	\left(\begin{array}{cccc}
	 0  & \col{0}   1 & \col{1}   2 & \col{2}   3 \\
	 8  & \col{4}   9 & \col{5}  10 & \col{6}  11 \\
	 16 & \col{8}  17 & \col{9}  18 & \col{10} 19 \\
	 24 & \col{12} 25 & \col{13} 26 & \col{14} 27 \\
	\hline
	\col{3}   4 &  5 &  6 &  7 \\
	\col{7}  12 & 13 & 14 & 15 \\
	\col{11} 20 & 21 & 22 & 23 \\
	\col{15} 28 & 29 & 30 & 31 \\
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}
	\col{3}   4 & \col{0}   1 & \col{1}   2 & \col{2}   3 \\
	\col{7}  12 & \col{4}   9 & \col{5}  10 & \col{6}  11 \\
	\col{11} 20 & \col{8}  17 & \col{9}  18 & \col{10} 19 \\
	\col{15} 28 & \col{12} 25 & \col{13} 26 & \col{14} 27 \\
	\hline
	 0 &  5 &  6 &  7 \\
	 8 & 13 & 14 & 15 \\
	16 & 21 & 22 & 23 \\
	24 & 29 & 30 & 31 \\
	\end{array}\right) 
	&&&	
	\left(\begin{array}{cccc}	
	\col{0}   1 & \col{1}   2 & \col{2}   3 & \col{3}   4 \\
	\col{4}   9 & \col{5}  10 & \col{6}  11 & \col{7}  12 \\
	\col{8}  17 & \col{9}  18 & \col{10} 19 & \col{11} 20 \\
	\col{12} 25 & \col{13} 26 & \col{14} 27 & \col{15} 28 \\
	\hline
	 5 &  6 &  7 &  0 \\
	13 & 14 & 15 &  8 \\
	21 & 22 & 23 & 16 \\
	29 & 30 & 31 & 24 \\
	\end{array}\right)
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
Transpose<4, 4, 2, 4>(a, b);
	\end{minted}
	possible sub-steps:
	\begin{align*}
	\begin{matrix}
	\textrm{array a}\\
	\\
	\left(\begin{array}{cccc}	
         	0 &         8  &          16 &          24 \\
	        1 &         9  &          17 &          25 \\
	\col{0} 2 & \col{4} 10 & \col{8}  18 & \col{12} 26 \\
	\col{1} 3 & \col{5} 11 & \col{9}  19 & \col{13} 27 \\
	\hline
	\col{2} 4 & \col{6} 12 & \col{10} 20 & \col{14} 28 \\	
	\col{3} 5 & \col{7} 13 & \col{11} 21 & \col{15} 29 \\
	        6 &         14 &          22 &          30 \\
	        7 &         15 &          23 &          31 
	\end{array}\right) 
	\\
	\\
	\textrm{temporary data} &&& \textrm{temporary data}  &&& \textrm{array b}\\
	\textrm{(in-lane transposition)}&&&\textrm{(swapped lanes)}&&&\textrm{(left shift registers $\times 2$)}\\
	\left(\begin{array}{cccc}
	0  &  1 & \col{0}   2 & \col{1}   3 \\
	8  &  9 & \col{4}  10 & \col{5}  11 \\
	16 & 17 & \col{8}  18 & \col{9}  19 \\
	24 & 25 & \col{12} 26 & \col{13} 27 \\
	\hline
	\col{2}   4 & \col{3}   5 &  6 &  7 \\
	\col{6}  12 & \col{7}  13 & 14 & 15 \\
	\col{10} 20 & \col{11} 21 & 22 & 23 \\
	\col{14} 28 & \col{15} 29 & 30 & 31 \\
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}
	0  &  1 &  6 &  7 \\
	8  &  9 & 14 & 15 \\
	16 & 17 & 22 & 23 \\
	24 & 25 & 30 & 31 \\
	\hline
	\col{2}   4 & \col{3}   5 & \col{0}   2 & \col{1}   3 \\
	\col{6}  12 & \col{7}  13 & \col{4}  10 & \col{5}  11 \\
	\col{10} 20 & \col{11} 21 & \col{8}  18 & \col{9}  19 \\
	\col{14} 28 & \col{15} 29 & \col{12} 26 & \col{13} 27 \\
	\end{array}\right) 
	&&&	
	\left(\begin{array}{cccc}
	 6 &  7 & 0  &  1 \\
	14 & 15 & 8  &  9  \\
	22 & 23 & 16 & 17 \\
	30 & 31 & 24 & 25 \\
	\hline
	\col{0}   2 & \col{1}   3 & \col{2}   4 & \col{3}   5 \\
	\col{4}  10 & \col{5}  11 & \col{6}  12 & \col{7}  13 \\
	\col{8}  18 & \col{9}  19 & \col{10} 20 & \col{11} 21 \\
	\col{12} 26 & \col{13} 27 & \col{14} 28 & \col{15} 29 \\
	\end{array}\right)
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

Again, if we use the size specific \cppInline{Transpose4x4} function, there is no need to do an actual reordering of the array.
Just pass the corresponding registers in the correct order to the function.

After discussing the previous two special cases, the general solution might be more or less obvious.
Combining both reordering techniques lets us transpose $4 \times 4$ matrices with arbitrary offsets in the source and result arrays.
Here are two step-by-step examples:

\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
	Transpose<4, 4, 1, 3>(a, b);
	\end{minted}
	possible sub-steps:	
	\begin{align*}
	\begin{matrix}
	\textrm{array a}&&&\textrm{function input}&&&\textrm{temporary data}\\
	&&& \textrm{(right shift registers $\times 3$)}&&&\textrm{(in-lane transposition)}\\
	\left(\begin{array}{cccc}	
	0         &         8  &          16 &          24 \\
	\col{0} 1 & \col{4} 9  & \col{8}  17 & \col{12} 25 \\
	\col{1} 2 & \col{5} 10 & \col{9}  18 & \col{13} 26 \\
	\col{2} 3 & \col{6} 11 & \col{10} 19 & \col{14} 27 \\
	\hline
	\col{3} 4 & \col{7} 12 & \col{11} 20 & \col{15} 28 \\	
	5         &         13 &          21 &          29 \\
	6         &         14 &          22 &          30 \\
	7         &         15 &          23 &          31 
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}	
	        8  &          16 &          24 & 0         \\
	\col{4} 9  & \col{8}  17 & \col{12} 25 & \col{0} 1 \\
	\col{5} 10 & \col{9}  18 & \col{13} 26 & \col{1} 2 \\
	\col{6} 11 & \col{10} 19 & \col{14} 27 & \col{2} 3 \\
	\hline
	\col{7} 12 & \col{11} 20 & \col{15} 28 & \col{3} 4 \\	
	        13 &          21 &          29 & 5         \\
	        14 &          22 &          30 & 6         \\
	        15 &          23 &          31 & 7         
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}	
	 8 & \col{4}   9 & \col{5}  10 & \col{6}  11 \\
	16 & \col{8}  17 & \col{9}  18 & \col{10} 19 \\
	24 & \col{12} 25 & \col{13} 26 & \col{14} 27 \\
	 0 & \col{0}   1 & \col{1}   2 & \col{2} 3 \\
	\hline
	\col{7}  12 & 13 & 14 & 15 \\
	\col{11} 20 & 21 & 22 & 23 \\
	\col{15} 28 & 29 & 30 & 31 \\
	\col{3}   4 &  5 &  6 &  7 \\
	\end{array}\right) 
	\\
	\\
	\textrm{temporary data} &&&\textrm{array b}\\
	\textrm{(left shift registers $\times 1$)}&&&\textrm{(copied lanes)}\\
	\left(\begin{array}{cccc}
	\col{4}   9 & \col{5}  10 & \col{6}  11 &  8\\
	\col{8}  17 & \col{9}  18 & \col{10} 19 & 16\\
	\col{12} 25 & \col{13} 26 & \col{14} 27 & 24\\
	\col{0}   1 & \col{1}   2 & \col{2}   3 &  0\\
	\hline
	13 & 14 & 15 & \col{7}  12\\
    21 & 22 & 23 & \col{11} 20\\
	29 & 30 & 31 & \col{15} 28\\
	 5 &  6 &  7 & \col{3}   4\\
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}
	          9 &          10 &          11 &          12\\
	         17 &          18 &          19 &          20\\
	         25 &          26 &          27 &          28\\
	\col{0}   1 & \col{1}   2 & \col{2}   3 & \col{3}   4\\
	\hline
	\col{4}   9 & \col{5}  10 & \col{6}  11 & \col{7}  12\\
	\col{8}  17 & \col{9}  18 & \col{10} 19 & \col{11} 20\\
	\col{12} 25 & \col{13} 26 & \col{14} 27 & \col{15} 28\\
	          1 &           2 &           3 &           4\\
	\end{array}\right) 
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{minted}{cpp}
	Transpose<4, 4, 3, 2>(a, b);
	\end{minted}
	possible sub-steps:	
	\begin{align*}
	\begin{matrix}
	\textrm{array a}&&&\textrm{function input}&&&\textrm{temporary data}\\
	&&& \textrm{(right shift registers $\times 2$)}&&&\textrm{(in-lane transposition)}\\
	\left(\begin{array}{cccc}	
	        0 &         8  &          16 &          24 \\
            1 &         9  &          17 &          25 \\
	        2 &         10 &          18 &          26 \\
	\col{0} 3 & \col{4} 11 & \col{8}  19 & \col{12} 27 \\
	\hline
	\col{1} 4 & \col{5} 12 & \col{9}  20 & \col{13} 28 \\	
	\col{2} 5 & \col{6} 13 & \col{10} 21 & \col{14} 29 \\
	\col{3} 6 & \col{7} 14 & \col{11} 22 & \col{15} 30 \\
	        7 &         15 &          23 &          31 
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}	
	         16 &          24 &         0 &         8  \\
	         17 &          25 &         1 &         9  \\
	         18 &          26 &         2 &         10 \\
	\col{8}  19 & \col{12} 27 & \col{0} 3 & \col{4} 11 \\
	\hline
	\col{9}  20 & \col{13} 28 & \col{1} 4 & \col{5} 12 \\	
	\col{10} 21 & \col{14} 29 & \col{2} 5 & \col{6} 13 \\
	\col{11} 22 & \col{15} 30 & \col{3} 6 & \col{7} 14 \\
	         23 &          31 &         7 &         15        
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}
	16 & 17 &  18 & \col{8}  19 \\
	24 & 25 &  26 & \col{12} 27 \\
	 0 &  1 &   2 & \col{0}   3 \\	
	 8 &  9 &  10 & \col{4}  11 \\
	\hline
	\col{9}  20 & \col{10} 21 & \col{11} 22 & 23 \\
	\col{13} 28 & \col{14} 29 & \col{15} 30 & 31 \\
	\col{1}   4 & \col{2}   5 & \col{3}   6 &  7 \\
	\col{5}  12 & \col{6}  13 & \col{7}  14 & 15 \\
	\end{array}\right) 
	\\
	\\
	\textrm{temporary data} &&&\textrm{array b}\\
	\textrm{(left shift registers $\times 3$)}&&&\textrm{(copied lanes)}\\
	\left(\begin{array}{cccc}
	\col{8}  19 & 16 & 17 &  18 \\
	\col{12} 27 & 24 & 25 &  26 \\
	\col{0}   3 &  0 &  1 &   2 \\	
	\col{4}  11 &  8 &  9 &  10 \\
	\hline
	23 & \col{9}  20 & \col{10} 21 & \col{11} 22 \\
	31 & \col{13} 28 & \col{14} 29 & \col{15} 30 \\
	 7 & \col{1}   4 & \col{2}   5 & \col{3}   6 \\
	15 & \col{5}  12 & \col{6}  13 & \col{7}  14 \\
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccc}
	         19 &          20 &          21 &          22 \\
	         27 &          28 &          29 &          30 \\
	\col{0}   3 & \col{1}   4 & \col{2}   5 & \col{3}   6 \\
	\col{4}  11 & \col{5}  12 & \col{6}  13 & \col{7}  14 \\
	\hline
	\col{8}  19 & \col{9}  20 & \col{10} 21 & \col{11} 22 \\
	\col{12} 27 & \col{13} 28 & \col{14} 29 & \col{15} 30 \\
 	          3 &           4 &           5 &           6 \\
	         11 &          12 &          13 &          14 \\
	\end{array}\right) 
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

In summary, only a single set of instructions has to be implemented for the case where no values need to be transferred across lane boundaries.
All other parameter combinations can reuse this code by shifting the order of input and output registers and swapping/copying the relevant lanes.




\subsubsection{Matrices with more rows and/or columns than the number of elements per lane}
\label{sec:Implementation_general_multi_lane_matrices} 

In this section, we discuss the implementation of the \cppInline{Transpose} functions for matrices with one of its dimensions being larger than the number of elements per lane.
The transposition of those kinds of matrices always requires permutations across lane boundaries.
Again, we will focus on the \cppInline{__m256} register type, but the described technique can also be used for other multi lane register types.

The idea is to use \cref{eq:block_matrix_transpose} in a way that the sub-matrix transpositions can be performed with in lane transpositions that have already been implemented before.
We will start with an easy example.
We transpose a $6 \times 6$ matrix which is stored with no register offset.
The result matrix should also have no offset.

The question is now, how to subdivide the matrix into smaller ones?
Let's have a look at the data layout of the source matrix and the target matrix after the transposition:


\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{align*}
	\begin{matrix}
	\textrm{source matrix}&&&\textrm{target matrix}\\
	&&&\textrm{(after transposition)}\\
	\left(\begin{array}{cccccc}
	\col{1} 0 & \col{5} 8  & \col{9}  16 & \col{13} 24 & \col{17} 32 & \col{21} 40 \\
	\col{1} 1 & \col{5} 9  & \col{9}  17 & \col{13} 25 & \col{17} 33 & \col{21} 41 \\
	\col{1} 2 & \col{5} 10 & \col{9}  18 & \col{13} 26 & \col{17} 34 & \col{21} 42 \\
	\col{1} 3 & \col{5} 11 & \col{9}  19 & \col{13} 27 & \col{17} 35 & \col{21} 43 \\
	\hline
	\col{3} 4 & \col{7} 12 & \col{11} 20 & \col{15} 28 & \col{19} 36 & \col{23} 44 \\	
	\col{3} 5 & \col{7} 13 & \col{11} 21 & \col{15} 29 & \col{19} 37 & \col{23} 45 \\
	        6 &         14 &          22 &          30 &          38 &          46 \\
	        7 &         15 &          23 &          31 &          39 &          47
	\end{array}\right) 
	&&&
		\left(\begin{array}{cccccc}
	\col{1}   0 & \col{1}   1 & \col{1}   2 & \col{1}   3 & \col{3}   4 & \col{3}   5 \\
	\col{5}   8 & \col{5}   9 & \col{5}  10 & \col{5}  11 & \col{7}  12 & \col{7}  13 \\
	\col{9}  16 & \col{9}  17 & \col{9}  18 & \col{9}  19 & \col{11} 20 & \col{11} 21 \\
	\col{13} 24 & \col{13} 25 & \col{13} 26 & \col{13} 27 & \col{15} 28 & \col{15} 29 \\
	\hline
	\col{17} 32 & \col{17} 33 & \col{17} 34 & \col{17} 35 & \col{19} 36 & \col{19} 37 \\	
	\col{21} 40 & \col{21} 41 & \col{21} 42 & \col{21} 43 & \col{23} 44 & \col{23} 45 \\
   	     \times &      \times &      \times &      \times &      \times &      \times \\
	     \times &      \times &      \times &      \times &      \times &      \times
	\end{array}\right) 
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

The different brightness's depending on the register lane of the source matrix help us to visualize the subdivision scheme. 
By comparing the initial and the result matrix one can identify 4 distinct fields.
Two where the brightness differs between the matrices and two where it does not change.
The sections with changing brightness's contain values that need to be transferred across lane boundaries.
In the following image the fields are separated from each other:

\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{align*}
	\begin{matrix}
	\textrm{source matrix}&&&\textrm{target matrix}\\
	&&&\textrm{(after transposition)}\\
	\left(\begin{array}{ccccccc}
	\col{1} 0 & \col{5} 8  & \col{9}  16 & \col{13} 24 && \col{17} 32 & \col{21} 40 \\
	\col{1} 1 & \col{5} 9  & \col{9}  17 & \col{13} 25 && \col{17} 33 & \col{21} 41 \\
	\col{1} 2 & \col{5} 10 & \col{9}  18 & \col{13} 26 && \col{17} 34 & \col{21} 42 \\
	\col{1} 3 & \col{5} 11 & \col{9}  19 & \col{13} 27 && \col{17} 35 & \col{21} 43 \\
	\\
	\col{3} 4 & \col{7} 12 & \col{11} 20 & \col{15} 28 && \col{19} 36 & \col{23} 44 \\	
	\col{3} 5 & \col{7} 13 & \col{11} 21 & \col{15} 29 && \col{19} 37 & \col{23} 45 \\
       	    6 &         14 &          22 &          30 &&          38 &          46 \\
	        7 &         15 &          23 &          31 &&          39 &          47
	\end{array}\right) 
	&&&
	\left(\begin{array}{ccccccc}
	\col{1}   0 & \col{1}   1 & \col{1}   2 & \col{1}   3 && \col{3}   4 & \col{3}   5 \\
	\col{5}   8 & \col{5}   9 & \col{5}  10 & \col{5}  11 && \col{7}  12 & \col{7}  13 \\
	\col{9}  16 & \col{9}  17 & \col{9}  18 & \col{9}  19 && \col{11} 20 & \col{11} 21 \\
	\col{13} 24 & \col{13} 25 & \col{13} 26 & \col{13} 27 && \col{15} 28 & \col{15} 29 \\
	\\
	\col{17} 32 & \col{17} 33 & \col{17} 34 & \col{17} 35 && \col{19} 36 & \col{19} 37 \\	
	\col{21} 40 & \col{21} 41 & \col{21} 42 & \col{21} 43 && \col{23} 44 & \col{23} 45 \\
	     \times &      \times &      \times &      \times &&      \times &      \times \\
	     \times &      \times &      \times &      \times &&      \times &      \times
	\end{array}\right) 
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

The matrix is now divided into multiple sub-matrices of size $4\times 4$, $4\times 2$, $2\times 4$ and $2\times 2$.
If our in lane transposition functions for small matrices are implemented in a way that all operations are exactly the same for both lanes, we can perform two sub-matrix transpositions at the same time.
However, there are now two possible ways, how to proceed.
We can perform a $4 \times 4$ transposition on the first 4 registers of the source matrix and a $4 \times 2$ transposition on the remaining 2.
Subsequent recombination of the lanes will yield the target matrix.
Alternatively, one can perform the lane permutations first and transpose afterwards.
In this case, one needs to perform a $4 \times 4$ and a $2 \times 4$ transposition.
The following image visualizes the sub steps of both approaches:

\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{align*}
	\begin{matrix}
	\textrm{source matrix}\\
	\\
	\left(\begin{array}{ccccccc}
	\col{1} 0 & \col{5} 8  & \col{9}  16 & \col{13} 24 && \col{17} 32 & \col{21} 40 \\
	\col{1} 1 & \col{5} 9  & \col{9}  17 & \col{13} 25 && \col{17} 33 & \col{21} 41 \\
	\col{1} 2 & \col{5} 10 & \col{9}  18 & \col{13} 26 && \col{17} 34 & \col{21} 42 \\
	\col{1} 3 & \col{5} 11 & \col{9}  19 & \col{13} 27 && \col{17} 35 & \col{21} 43 \\
	\\
	\col{3} 4 & \col{7} 12 & \col{11} 20 & \col{15} 28 && \col{19} 36 & \col{23} 44 \\	
	\col{3} 5 & \col{7} 13 & \col{11} 21 & \col{15} 29 && \col{19} 37 & \col{23} 45 \\
	        6 &         14 &          22 &          30 &&          38 &          46 \\
	        7 &         15 &          23 &          31 &&          39 &          47
	\end{array}\right) 
	\\
	\\
	\\
	\\
	\textbf{\large Approach 1:}
	\\
	\\
	\textrm{temporary data}&&&\textrm{target matrix}\\
	\textrm{(after }4\times 4 \textrm{ and }4\times 2\textrm{ transposition)}&&&\textrm{(after lane permutations)}\\
	\left(\begin{array}{ccccccccc}
	\col{1}   0 & \col{1}   1 & \col{1}   2 & \col{1}   3 && \col{17} 32 & \col{17} 33 & \col{17} 34 & \col{17} 35 \\
	\col{5}   8 & \col{5}   9 & \col{5}  10 & \col{5}  11 && \col{21} 40 & \col{21} 41 & \col{21} 42 & \col{21} 43 \\
	\col{9}  16 & \col{9}  17 & \col{9}  18 & \col{9}  19 &&      \times &      \times &      \times &      \times \\
	\col{13} 24 & \col{13} 25 & \col{13} 26 & \col{13} 27 &&      \times &      \times &      \times &      \times \\
	\\
	\col{3}   4 & \col{3}   5 &           6 &           7 && \col{19} 36 & \col{19} 37 &          38 &          39 \\	
	\col{7}  12 & \col{7}  13 &          14 &          15 && \col{23} 44 & \col{23} 45 &          46 &          47 \\
	\col{11} 20 & \col{11} 21 &          22 &          23 &&      \times &      \times &     \times  &      \times \\
	\col{15} 28 & \col{15} 29 &          30 &          31 &&      \times &      \times &      \times &      \times 
	\end{array}\right)  
	&&&
	\left(\begin{array}{ccccccc}
	\col{1}   0 & \col{1}   1 & \col{1}   2 & \col{1}   3 && \col{3}   4 & \col{3}   5 \\
	\col{5}   8 & \col{5}   9 & \col{5}  10 & \col{5}  11 && \col{7}  12 & \col{7}  13 \\
	\col{9}  16 & \col{9}  17 & \col{9}  18 & \col{9}  19 && \col{11} 20 & \col{11} 21 \\
	\col{13} 24 & \col{13} 25 & \col{13} 26 & \col{13} 27 && \col{15} 28 & \col{15} 29 \\
	\\
	\col{17} 32 & \col{17} 33 & \col{17} 34 & \col{17} 35 && \col{19} 36 & \col{19} 37 \\	
	\col{21} 40 & \col{21} 41 & \col{21} 42 & \col{21} 43 && \col{23} 44 & \col{23} 45 \\
	\times &      \times &      \times &      \times &&      \times &      \times \\
	\times &      \times &      \times &      \times &&      \times &      \times
	\end{array}\right) 
	\\
	\\
	\\
	\\
	\textbf{\large Approach 2:}
	\\
	\\
	\textrm{temporary data}&&&\textrm{target matrix}\\
	\textrm{(after lane permutations)}&&&\textrm{(after }4\times 4 \textrm{ and }2\times 4\textrm{ transposition)}\\
	\left(\begin{array}{ccccccccc}
	\col{1} 0   & \col{5} 8   & \col{9}  16 & \col{13} 24 && \col{3} 4  & \col{7} 12   & \col{11} 20 & \col{15} 28 \\
	\col{1} 1   & \col{5} 9   & \col{9}  17 & \col{13} 25 && \col{3} 5  & \col{7} 13   & \col{11} 21 & \col{15} 29 \\
	\col{1} 2   & \col{5} 10  & \col{9}  18 & \col{13} 26 &&         6  &         14   &          22 &          30 \\
	\col{1} 3   & \col{5} 11  & \col{9}  19 & \col{13} 27 &&         7  &         15   &          23 &          31 \\
	\\
	\col{17} 32 & \col{21} 40 &          20 &          28 && \col{19} 36 & \col{23} 44 &      \times &      \times\\	
	\col{17} 33 & \col{21} 41 &          21 &          29 && \col{19} 37 & \col{23} 45 &      \times &      \times\\
	\col{17} 34 & \col{21} 42 &          22 &          30 &&          38 &          46 &      \times &      \times\\
	\col{17} 35 & \col{21} 43 &          23 &          31 &&          39 &          47 &      \times &      \times
	\end{array}\right)  
	&&&
	\left(\begin{array}{ccccccc}
	\col{1}   0 & \col{1}   1 & \col{1}   2 & \col{1}   3 && \col{3}   4 & \col{3}   5 \\
	\col{5}   8 & \col{5}   9 & \col{5}  10 & \col{5}  11 && \col{7}  12 & \col{7}  13 \\
	\col{9}  16 & \col{9}  17 & \col{9}  18 & \col{9}  19 && \col{11} 20 & \col{11} 21 \\
	\col{13} 24 & \col{13} 25 & \col{13} 26 & \col{13} 27 && \col{15} 28 & \col{15} 29 \\
	\\
	\col{17} 32 & \col{17} 33 & \col{17} 34 & \col{17} 35 && \col{19} 36 & \col{19} 37 \\	
	\col{21} 40 & \col{21} 41 & \col{21} 42 & \col{21} 43 && \col{23} 44 & \col{23} 45 \\
	\times &      \times &      \times &      \times &&      \times &      \times \\
	\times &      \times &      \times &      \times &&      \times &      \times
	\end{array}\right) 	
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

It depends on several factors which of those approaches is more efficient.
First, the efficiency of the sub-matrix transpositions needs to be considered.
The implementation of the $4 \times 2$ transposition might need a different number of CPU cycles than the $2 \times 4$ transposition.
Additionally, the shape of the matrix has an influence on the efficiency of both approaches too.
For example, if we would have a $8 \times 5$ matrix instead, transposing the sub-matrices before the lane permutations would need a $4 \times 4$ and a $4 \times 1$ transposition, while the other approach would need two $4 \times 4$ transpositions.
However, the first version would need 8 subsequent lane permutations while the second would only need 5.

Now we will have a look into the situation, were the source matrix does not have an offset, but the result matrix does.
As an example, we will use a $6 \times 5$ matrix and a target offset of $2$.
Here is the visualization of this example:

\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{align*}
	\begin{matrix}
	\textrm{source matrix}&&&\textrm{target matrix}\\
	&&&\textrm{(after transposition)}\\
	\left(\begin{array}{ccccc}
	\col{1} 0 & \col{5} 8  & \col{9}  16 & \col{13} 24 & \col{17} 32 \\
	\col{1} 1 & \col{5} 9  & \col{9}  17 & \col{13} 25 & \col{17} 33 \\
	\col{1} 2 & \col{5} 10 & \col{9}  18 & \col{13} 26 & \col{17} 34 \\
	\col{1} 3 & \col{5} 11 & \col{9}  19 & \col{13} 27 & \col{17} 35 \\
	\hline
	\col{3} 4 & \col{7} 12 & \col{11} 20 & \col{15} 28 & \col{19} 36 \\	
	\col{3} 5 & \col{7} 13 & \col{11} 21 & \col{15} 29 & \col{19} 37 \\
	        6 &         14 &          22 &          30 &          38 \\
	        7 &         15 &          23 &          31 &          39 
	\end{array}\right) 
	&&&
	\left(\begin{array}{cccccc}
	 	 \times &      \times &      \times &      \times &      \times &      \times \\
		 \times &      \times &      \times &      \times &      \times &      \times \\
	\col{1}   0 & \col{1}   1 & \col{1}   2 & \col{1}   3 & \col{3}   4 & \col{3}   5 \\
	\col{5}   8 & \col{5}   9 & \col{5}  10 & \col{5}  11 & \col{7}  12 & \col{7}  13 \\
	\hline
	\col{9}  16 & \col{9}  17 & \col{9}  18 & \col{9}  19 & \col{11} 20 & \col{11} 21 \\
	\col{13} 24 & \col{13} 25 & \col{13} 26 & \col{13} 27 & \col{15} 28 & \col{15} 29 \\
	\col{17} 32 & \col{17} 33 & \col{17} 34 & \col{17} 35 & \col{19} 36 & \col{19} 37 \\	
	     \times &      \times &      \times &      \times &      \times &      \times
	\end{array}\right) 
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

Since the matrix isn't symmetric anymore and due to the offset, it is not as easy anymore to see in the image where to subdivide the matrix.
However, if you compare which lanes need to be permuted and which don't you will get to the following result:

\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{align*}
	\begin{matrix}
	\textrm{source matrix}&&&\textrm{target matrix}\\
	&&&\textrm{(after transposition)}\\
	\left(\begin{array}{cccccc}
	\col{1} 0 & \col{5} 8  && \col{9}  16 & \col{13} 24 & \col{17} 32 \\
	\col{1} 1 & \col{5} 9  && \col{9}  17 & \col{13} 25 & \col{17} 33 \\
	\col{1} 2 & \col{5} 10 && \col{9}  18 & \col{13} 26 & \col{17} 34 \\
	\col{1} 3 & \col{5} 11 && \col{9}  19 & \col{13} 27 & \col{17} 35 \\
	\\
	\col{3} 4 & \col{7} 12 && \col{11} 20 & \col{15} 28 & \col{19} 36 \\	
	\col{3} 5 & \col{7} 13 && \col{11} 21 & \col{15} 29 & \col{19} 37 \\
	        6 &         14 &&          22 &          30 &          38 \\
	        7 &         15 &&          23 &          31 &          39 
	\end{array}\right) 
	&&&
	\left(\begin{array}{ccccccc}
    	 \times &      \times &      \times &      \times &&      \times &      \times \\
	     \times &      \times &      \times &      \times &&      \times &      \times \\
	\col{1}   0 & \col{1}   1 & \col{1}   2 & \col{1}   3 && \col{3}   4 & \col{3}   5 \\
	\col{5}   8 & \col{5}   9 & \col{5}  10 & \col{5}  11 && \col{7}  12 & \col{7}  13 \\
	\\
	\col{9}  16 & \col{9}  17 & \col{9}  18 & \col{9}  19 && \col{11} 20 & \col{11} 21 \\
	\col{13} 24 & \col{13} 25 & \col{13} 26 & \col{13} 27 && \col{15} 28 & \col{15} 29 \\
	\col{17} 32 & \col{17} 33 & \col{17} 34 & \col{17} 35 && \col{19} 36 & \col{19} 37 \\	
	     \times &      \times &      \times &      \times &&      \times &      \times
	\end{array}\right) 
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

In general, the subdivision depends on the lane boundaries of source and target matrix.
By imagining the lane boundaries as additional columns and rows in the matrix that need to be transposed too, finding the subdivisions shouldn't be a problem anymore.

As in the previous case we can choose to perform the sub-matrix transposition before the lane permutations or the other way around.
Depending on the choice, there are some things to consider.
If we perform the sub-matrix transpositions first, we need a $4 \times 2$ transposition for the first 2 registers and a $4 \times 3$ transposition for the remaining 3.
Note that we need a result matrix offset of 2 for the $4 \times 2$ transposition to get all values to the correct position.
Afterwards 6 lane permutations are required to recombine the lanes as needed.

If we instead choose to perform the lane permutations first, we have to recombine the lanes in a way that the subsequent sub-matrix transpositions directly yield the desired result matrix.
This requires us to introduce additional temporary registers, so that we have 4 registers per sub-matrix.
Now the values inside the upper lanes have to be aligned at the right boundary so that they and up at the bottom after the transposition.
The values in the lower lanes need to be aligned at the left boundary to get them into the top rows after the transposition.
Have a look into the second approach of the visualization below to get a better understanding of the previous description.
Performing a $4 \times 4$ and a $2 \times 4$ without offsets yield the target matrix.



\vspace{1cm}
\begin{minipage}{\linewidth}
	\begin{align*}
	\begin{matrix}
	\textrm{source matrix}\\
	\\
	\left(\begin{array}{cccccc}
	\col{1} 0 & \col{5} 8  && \col{9}  16 & \col{13} 24 & \col{17} 32 \\
	\col{1} 1 & \col{5} 9  && \col{9}  17 & \col{13} 25 & \col{17} 33 \\
	\col{1} 2 & \col{5} 10 && \col{9}  18 & \col{13} 26 & \col{17} 34 \\
	\col{1} 3 & \col{5} 11 && \col{9}  19 & \col{13} 27 & \col{17} 35 \\
	\\
	\col{3} 4 & \col{7} 12 && \col{11} 20 & \col{15} 28 & \col{19} 36 \\	
	\col{3} 5 & \col{7} 13 && \col{11} 21 & \col{15} 29 & \col{19} 37 \\
	6 &         14 &&          22 &          30 &          38 \\
	7 &         15 &&          23 &          31 &          39 
	\end{array}\right) 
	\\
	\\
	\\
	\\
	\textbf{\large Approach 1:}
	\\
	\\
	\textrm{temporary data}&&&\textrm{target matrix}\\
	\textrm{(after 4}\times\textrm{2 and 4}\times\textrm{3 transposition)}&&&\textrm{(after lane permutations)}\\
	\left(\begin{array}{ccccccccc}
	     \times &      \times &      \times &      \times && \col{9}  16 & \col{9}  17 & \col{9}  18 & \col{9}  19 \\
	     \times &      \times &      \times &      \times && \col{13} 24 & \col{13} 25 & \col{13} 26 & \col{13} 27 \\
	\col{1}   0 & \col{1}   1 & \col{1}   2 & \col{1}   3 && \col{17} 32 & \col{17} 33 & \col{17} 34 & \col{17} 35 \\
	\col{5}   8 & \col{5}   9 & \col{5}  10 & \col{5}  11 &&      \times &      \times &      \times &      \times \\
	\\
	     \times &      \times &      \times &      \times && \col{11} 20 & \col{11} 21 &          22 &          23 \\	
	     \times &      \times &      \times &      \times && \col{15} 28 & \col{15} 29 &          30 &          31 \\
	\col{3}   4 & \col{3}   5 &           6 &           7 && \col{19} 36 & \col{19} 37 &          38 &          39 \\
	\col{7}  12 & \col{7}  13 &          14 &          15 &&      \times &      \times &      \times &      \times
	\end{array}\right) 
	&&&
	\left(\begin{array}{ccccccc}
	\times &      \times &      \times &      \times &&      \times &      \times \\
	\times &      \times &      \times &      \times &&      \times &      \times \\
	\col{1}   0 & \col{1}   1 & \col{1}   2 & \col{1}   3 && \col{3}   4 & \col{3}   5 \\
	\col{5}   8 & \col{5}   9 & \col{5}  10 & \col{5}  11 && \col{7}  12 & \col{7}  13 \\
	\\
	\col{9}  16 & \col{9}  17 & \col{9}  18 & \col{9}  19 && \col{11} 20 & \col{11} 21 \\
	\col{13} 24 & \col{13} 25 & \col{13} 26 & \col{13} 27 && \col{15} 28 & \col{15} 29 \\
	\col{17} 32 & \col{17} 33 & \col{17} 34 & \col{17} 35 && \col{19} 36 & \col{19} 37 \\	
	\times &      \times &      \times &      \times &&      \times &      \times
	\end{array}\right) 
	\\
	\\
	\\
	\\
	\textbf{\large Approach 2:}
	\\
	\\
	\textrm{temporary data}&&&\textrm{target matrix}\\
	\textrm{(after lane permutations)}&&&\textrm{(after 4}\times\textrm{4 and 2}\times\textrm{4 transposition)}\\
	\left(\begin{array}{ccccccccc}
	         12 &      \times &  \col{1}  0 &  \col{5}  8 &&          16 &          24 & \col{3}  4 & \col{7} 12 \\
	         13 &      \times &  \col{1}  1 &  \col{5}  9 &&          17 &          25 & \col{3}  5 & \col{7} 13 \\
	         14 &      \times &  \col{1}  2 &  \col{5} 10 &&          18 &          26 &          6 &         14 \\
	         15 &      \times &  \col{1}  3 &  \col{5} 11 &&          19 &          27 &          7 &         15 \\
	\\
	\col{9}  16 & \col{13} 24 & \col{17} 32 &          12 && \col{11} 20 & \col{15} 28 & \col{19} 36 &        16 \\	
 	\col{9}  17 & \col{13} 25 & \col{17} 33 &          13 && \col{11} 21 & \col{15} 29 & \col{19} 37 &        17 \\
	\col{9}  18 & \col{13} 26 & \col{17} 34 &          14 &&          22 &          30 &          38 &        18 \\
	\col{9}  19 & \col{13} 27 & \col{17} 35 &          15 &&          23 &          31 &          39 &        19 
	\end{array}\right) 
	&&&
	\left(\begin{array}{ccccccc}
	         12 &          13 &          14 &          15 &&      \times &      \times \\
	     \times &      \times &      \times &      \times &&      \times &      \times \\
	\col{1}   0 & \col{1}   1 & \col{1}   2 & \col{1}   3 && \col{3}   4 & \col{3}   5 \\
	\col{5}   8 & \col{5}   9 & \col{5}  10 & \col{5}  11 && \col{7}  12 & \col{7}  13 \\
	\\
	\col{9}  16 & \col{9}  17 & \col{9}  18 & \col{9}  19 && \col{11} 20 & \col{11} 21 \\
	\col{13} 24 & \col{13} 25 & \col{13} 26 & \col{13} 27 && \col{15} 28 & \col{15} 29 \\
	\col{17} 32 & \col{17} 33 & \col{17} 34 & \col{17} 35 && \col{19} 36 & \col{19} 37 \\	
	     \times &      \times &      \times &      \times &&          16 &          17
	\end{array}\right) 
	\end{matrix}
	\end{align*}
\end{minipage}
\vspace{1cm}

It might seem, that the second approach is more costly, since it performs a $4 \times 4$ transposition while the first one only needs a $4 \times 3$ transposition.
However, if you look closely at the data in the first step of the second approach, you will see, that it only needs 4 lane permutations instead of 6.
In the first register only the second lane is relevant to the first transposition and in the last register only the first lane is relevant for the second transposition.
Therefore, we can perform a single lane recombination and the same register in both sub-matrix transpositions, saving us 1 permutation.
Then there are only 3 registers left, that need to be transferred to another lane.

To be sure, which approach is the better choice one has to benchmark it.
Another option is to look at the individual instructions and calculate an expected number of CPU cycles, which is quite accurate most of the times, but during the implementation derivations of 1 to 2 cycles between benchmark and expected cycle number were observed in some cases.
